<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="BehaviorDesc" xml:space="preserve">
    <value>此节点表示当前的行为</value>
  </data>
  <data name="BehaviorFilename" xml:space="preserve">
    <value>文件名</value>
  </data>
  <data name="BehaviorFilenameDesc" xml:space="preserve">
    <value>包含此行为树的文件名</value>
  </data>
  <data name="BehaviorIsEmptyError" xml:space="preserve">
    <value>行为树是空的</value>
  </data>
  <data name="CategoryBasic" xml:space="preserve">
    <value>基本</value>
  </data>
  <data name="CategoryComment" xml:space="preserve">
    <value>注释</value>
  </data>
  <data name="CategoryDesign" xml:space="preserve">
    <value>设计</value>
  </data>
  <data name="ConditionConnectorsFalse" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="ConditionConnectorsTrue" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="DecoratorHasNoChildError" xml:space="preserve">
    <value>装饰器没有子节点</value>
  </data>
  <data name="EventBlockEvent" xml:space="preserve">
    <value>阻塞</value>
  </data>
  <data name="EventBlockEventDesc" xml:space="preserve">
    <value>当事件阻塞时，返回真</value>
  </data>
  <data name="ExceptionBehaviorNodeTypeInvalid" xml:space="preserve">
    <value>The used behaviour node type does not implement Nodes.Behavior or is abstract.</value>
  </data>
  <data name="ExceptionBothStylesNull" xml:space="preserve">
    <value>Both styles may not be null.</value>
  </data>
  <data name="ExceptionCreateNodeViewDataFromNodeViewData" xml:space="preserve">
    <value>It is not allowed to create a node view data from another one. Use the original node for this.</value>
  </data>
  <data name="ExceptionDefaultStyleNull" xml:space="preserve">
    <value>Default style may not be null.</value>
  </data>
  <data name="ExceptionDesignerAttributeEnumCouldNotParseValue" xml:space="preserve">
    <value>Could not parse value {0}</value>
  </data>
  <data name="ExceptionDesignerAttributeEnumCouldNotReadValue" xml:space="preserve">
    <value>Could not read value {0}</value>
  </data>
  <data name="ExceptionDesignerAttributeEnumIllegalEnumIndex" xml:space="preserve">
    <value>Invalid enum index found {0}</value>
  </data>
  <data name="ExceptionDesignerAttributeEnumValueIllegal" xml:space="preserve">
    <value>Enum value {0} is illegal</value>
  </data>
  <data name="ExceptionDesignerAttributeExpectedEnum" xml:space="preserve">
    <value>Enum expected {0}</value>
  </data>
  <data name="ExceptionDesignerAttributeIllegalBooleanValue" xml:space="preserve">
    <value>Illegal boolean value {0}</value>
  </data>
  <data name="ExceptionDesignerAttributeIllegalFloatValue" xml:space="preserve">
    <value>Illegal float value {0}</value>
  </data>
  <data name="ExceptionDesignerAttributeIllegalIntegerValue" xml:space="preserve">
    <value>Illegal integer value {0}</value>
  </data>
  <data name="ExceptionDesignerAttributeInvalidType" xml:space="preserve">
    <value>Invalid type</value>
  </data>
  <data name="ExceptionDuplicatedConnectorIdentifier" xml:space="preserve">
    <value>A duplicated connector identifier was found. The identifier must be unique over the whole solution!</value>
  </data>
  <data name="ExceptionFileManagerXMLMissingAttribute" xml:space="preserve">
    <value>Missing attribute "{0}"</value>
  </data>
  <data name="ExceptionInvalidDefinitionName" xml:space="preserve">
    <value>The name of a definition may not contain any spaces.</value>
  </data>
  <data name="ExceptionIsNotNodeViewData" xml:space="preserve">
    <value>This operation is only allowed on NodeViewData nodes.</value>
  </data>
  <data name="ExceptionMissingEventConstructor" xml:space="preserve">
    <value>Could not create event of type {0}. Constructor may only require the node it is created for as a parameter.</value>
  </data>
  <data name="ExceptionMissingNodeConstructor" xml:space="preserve">
    <value>Could not create node of type {0}. Constructor may not require any parameters.</value>
  </data>
  <data name="ExceptionMultipleBehaviorManagerInterfaces" xml:space="preserve">
    <value>There can only be one BehaviorManagerInterface.</value>
  </data>
  <data name="ExceptionMultipleDesignerAttributes" xml:space="preserve">
    <value>Only one loadable or savable attribute is allowed.</value>
  </data>
  <data name="ExceptionNodeHasTooManyChildren" xml:space="preserve">
    <value>The node is not allowed to have more children.</value>
  </data>
  <data name="ExceptionNodeIsNoChild" xml:space="preserve">
    <value>Node is not a child of this node.</value>
  </data>
  <data name="ExceptionNoSubItemForConnector" xml:space="preserve">
    <value>No subitem for the connector could be found.</value>
  </data>
  <data name="ExceptionNotImplementDefaultObject" xml:space="preserve">
    <value>The given type does not implement the DefaultObject interface.</value>
  </data>
  <data name="ExceptionPropertyCannotBeRead" xml:space="preserve">
    <value>All designer properties must be readable.</value>
  </data>
  <data name="ExceptionPropertyCannotBeWritten" xml:space="preserve">
    <value>All designer properties must be writable or flagged as read only and no save.</value>
  </data>
  <data name="ExceptionReferencedBehaviorNodeTypeInvalid" xml:space="preserve">
    <value>The used referenced behaviour node type does not implement Nodes.ReferencedBehavior or is abstract.</value>
  </data>
  <data name="ExceptionSubItemIsNoChild" xml:space="preserve">
    <value>The subitem does not belong to this node.</value>
  </data>
  <data name="ExceptionUnhandledCommentColor" xml:space="preserve">
    <value>The given color is not handled.</value>
  </data>
  <data name="ExceptionUnhandledNodeShape" xml:space="preserve">
    <value>Unhandled node shape.</value>
  </data>
  <data name="ExceptionUnknownEventType" xml:space="preserve">
    <value>No such event type {0}.</value>
  </data>
  <data name="ExceptionUnknownNodeType" xml:space="preserve">
    <value>No such node type {0}.</value>
  </data>
  <data name="ExceptionWrongNodeTagType" xml:space="preserve">
    <value>The given node tag type cannot be used with the given type.</value>
  </data>
  <data name="ImpulseDelay" xml:space="preserve">
    <value>延迟</value>
  </data>
  <data name="ImpulseDelayDesc" xml:space="preserve">
    <value>节点被激活时，所必需的时间</value>
  </data>
  <data name="ImpulseDuration" xml:space="preserve">
    <value>持续时间</value>
  </data>
  <data name="ImpulseDurationDesc" xml:space="preserve">
    <value>决定当节点变得有效时，事件的持续时间</value>
  </data>
  <data name="NodeCommentBackground" xml:space="preserve">
    <value>背景颜色</value>
  </data>
  <data name="NodeCommentBackgroundDesc" xml:space="preserve">
    <value>节点及其子节点的背景颜色</value>
  </data>
  <data name="NodeCommentText" xml:space="preserve">
    <value>注释</value>
  </data>
  <data name="NodeCommentTextDesc" xml:space="preserve">
    <value>用于显示节点及其子节点的文字注释</value>
  </data>
  <data name="ParallelNoChildrenError" xml:space="preserve">
    <value>Parallel has no children.</value>
  </data>
  <data name="ParallelOnlyOneChildError" xml:space="preserve">
    <value>Parallel has only one child and could be removed.</value>
  </data>
  <data name="ReferencedBehaviorCircularReferenceError" xml:space="preserve">
    <value>Found circular reference.</value>
  </data>
  <data name="ReferencedBehaviorDesc" xml:space="preserve">
    <value>该节点引用一棵行为树</value>
  </data>
  <data name="ReferencedBehaviorPath" xml:space="preserve">
    <value>引用文件名</value>
  </data>
  <data name="ReferencedBehaviorPathDesc" xml:space="preserve">
    <value>作为引用行为树的文件名</value>
  </data>
  <data name="SelectorNoChildrenError" xml:space="preserve">
    <value>选择器没有子节点</value>
  </data>
  <data name="SelectorOnlyOneChildError" xml:space="preserve">
    <value>选择器只有一个子节点</value>
  </data>
  <data name="SequenceNoChildrenError" xml:space="preserve">
    <value>序列节点没有子节点</value>
  </data>
  <data name="SequenceOnlyOneChildError" xml:space="preserve">
    <value>序列节点只有一个子节点</value>
  </data>
  <data name="UnitsSeconds" xml:space="preserve">
    <value>秒</value>
  </data>
  <data name="ExceptionAdditionalAssemblyNotLoaded" xml:space="preserve">
    <value>The additional assembly {0} could not be loaded.</value>
  </data>
  <data name="CategoryVersion" xml:space="preserve">
    <value>节点信息</value>
  </data>
  <data name="NodeClassVersion" xml:space="preserve">
    <value>类版本</value>
  </data>
  <data name="NodeClassVersionDesc" xml:space="preserve">
    <value>类的版本号。当节点的版本号低于类的版本号时，该节点将被更新</value>
  </data>
  <data name="NodeVersion" xml:space="preserve">
    <value>版本</value>
  </data>
  <data name="NodeVersionDesc" xml:space="preserve">
    <value>节点的版本号，用于当数据结构变化时，更新节点</value>
  </data>
  <data name="ExceptionMissingOverrideConstructor" xml:space="preserve">
    <value>Could not create override of type {0}. Constructor may only require the node it is created for as a parameter.</value>
  </data>
  <data name="OverrideRandom" xml:space="preserve">
    <value>随机</value>
  </data>
  <data name="OverrideRandomDesc" xml:space="preserve">
    <value>Changes an attribute to return a random value.</value>
  </data>
  <data name="ExceptionDesignerAttributeUnsupportedType" xml:space="preserve">
    <value>The given type is not allowed by this property.</value>
  </data>
  <data name="DesignerNodePropertyNone" xml:space="preserve">
    <value>&lt;None&gt;</value>
  </data>
  <data name="ExceptionDesignerAttributeCouldNotRetrieveNode" xml:space="preserve">
    <value>Could not retrieve the node of {0}.</value>
  </data>
  <data name="ExceptionLinkedPropertyNotFound" xml:space="preserve">
    <value>The linked property {0} could not be found in {1}.</value>
  </data>
  <data name="OverrideProperty" xml:space="preserve">
    <value>覆盖</value>
  </data>
  <data name="OverridePropertyDesc" xml:space="preserve">
    <value>将被覆写的节点属性</value>
  </data>
  <data name="RandomMax" xml:space="preserve">
    <value>Max</value>
  </data>
  <data name="RandomMaxDesc" xml:space="preserve">
    <value>可能的最大值</value>
  </data>
  <data name="RandomMin" xml:space="preserve">
    <value>Min</value>
  </data>
  <data name="RandomMinDesc" xml:space="preserve">
    <value>可能的最小值</value>
  </data>
  <data name="BehaviorAgentType" xml:space="preserve">
    <value>Agent类型</value>
  </data>
  <data name="BehaviorAgentTypeDesc" xml:space="preserve">
    <value>Agent类型决定了其行为</value>
  </data>
  <data name="AgentEvent" xml:space="preserve">
    <value>事件</value>
  </data>
  <data name="AgentEventDesc" xml:space="preserve">
    <value>事件</value>
  </data>
  <data name="AgentMethod" xml:space="preserve">
    <value>方法</value>
  </data>
  <data name="AgentMethodDesc" xml:space="preserve">
    <value>动作节点更新时执行的操作，不能为空</value>
  </data>
  <data name="ConditionNegate" xml:space="preserve">
    <value>取反</value>
  </data>
  <data name="ConditionNegateDesc" xml:space="preserve">
    <value>非</value>
  </data>
  <data name="OperandLeft" xml:space="preserve">
    <value>左参数</value>
  </data>
  <data name="OperandLeftDesc" xml:space="preserve">
    <value>左参数</value>
  </data>
  <data name="OperandRight" xml:space="preserve">
    <value>右参数</value>
  </data>
  <data name="OperandRightDesc" xml:space="preserve">
    <value>右参数</value>
  </data>
  <data name="Operator" xml:space="preserve">
    <value>操作符</value>
  </data>
  <data name="OperatorDesc" xml:space="preserve">
    <value>操作符</value>
  </data>
  <data name="BehaviorEventName" xml:space="preserve">
    <value>事件名字</value>
  </data>
  <data name="BehaviorEventNameDesc" xml:space="preserve">
    <value>事件名字</value>
  </data>
  <data name="CategoryPar" xml:space="preserve">
    <value>变量</value>
  </data>
  <data name="DescriptorDesc" xml:space="preserve">
    <value>描述符</value>
  </data>
  <data name="BehaviorDomain" xml:space="preserve">
    <value>域</value>
  </data>
  <data name="BehaviorDomainDesc" xml:space="preserve">
    <value>域标识符，如攻击、防御等</value>
  </data>
  <data name="BehaviorDomains" xml:space="preserve">
    <value>域</value>
  </data>
  <data name="BehaviorDomainsDesc" xml:space="preserve">
    <value>域标识符，如攻击、防御等，用空格分隔</value>
  </data>
  <data name="DescriptorRefDesc" xml:space="preserve">
    <value>引用描述符</value>
  </data>
  <data name="BinaryOperator" xml:space="preserve">
    <value>联合</value>
  </data>
  <data name="BinaryOperatorDesc" xml:space="preserve">
    <value>如何连接多个条件</value>
  </data>
  <data name="AgentEnter" xml:space="preserve">
    <value>进入</value>
  </data>
  <data name="AgentEnterDesc" xml:space="preserve">
    <value>进入</value>
  </data>
  <data name="AgentExit" xml:space="preserve">
    <value>退出</value>
  </data>
  <data name="AgentExitDesc" xml:space="preserve">
    <value>退出</value>
  </data>
  <data name="DecorateWhenChildEnds" xml:space="preserve">
    <value>子节点结束时</value>
  </data>
  <data name="DecorateWhenChildEndsDesc" xml:space="preserve">
    <value>如果为真，那么装饰器仅在子节点结束时其作用</value>
  </data>
  <data name="Event" xml:space="preserve">
    <value>事件</value>
  </data>
  <data name="EventDesc" xml:space="preserve">
    <value>事件</value>
  </data>
  <data name="Attachments" xml:space="preserve">
    <value>附件</value>
  </data>
  <data name="Composites" xml:space="preserve">
    <value>组合</value>
  </data>
  <data name="Conditions" xml:space="preserve">
    <value>条件</value>
  </data>
  <data name="Decorators" xml:space="preserve">
    <value>装饰器</value>
  </data>
  <data name="EventHandling" xml:space="preserve">
    <value>事件处理</value>
  </data>
  <data name="Leaf" xml:space="preserve">
    <value>叶节点</value>
  </data>
  <data name="Selectors" xml:space="preserve">
    <value>选择器</value>
  </data>
  <data name="Sequences" xml:space="preserve">
    <value>序列</value>
  </data>
  <data name="TriggeredOnce" xml:space="preserve">
    <value>触发一次</value>
  </data>
  <data name="TriggeredOnceDesc" xml:space="preserve">
    <value>仅触发一次，触发过后就不再触发</value>
  </data>
  <data name="EventName" xml:space="preserve">
    <value>事件</value>
  </data>
  <data name="ConnectError" xml:space="preserve">
    <value>连接错误</value>
  </data>
  <data name="ExportFileWarning" xml:space="preserve">
    <value>导出文件警告</value>
  </data>
  <data name="FileWarning" xml:space="preserve">
    <value>文件警告</value>
  </data>
  <data name="InvalidMeta" xml:space="preserve">
    <value>元数据文件有错误</value>
  </data>
  <data name="LoadError" xml:space="preserve">
    <value>加载错误</value>
  </data>
  <data name="LoadWarning" xml:space="preserve">
    <value>加载警告</value>
  </data>
  <data name="ReferencedBehaviorError" xml:space="preserve">
    <value>找不到引用的行为树文件"{0}"！</value>
  </data>
  <data name="SaveError" xml:space="preserve">
    <value>保存错误</value>
  </data>
  <data name="SaveFileWarning" xml:space="preserve">
    <value>保存文件警告</value>
  </data>
  <data name="SaveWarningInfo" xml:space="preserve">
    <value>文件{0}是只读的。

是   : 覆盖该文件
否   : 不覆盖该文件
取消 : 放弃所有操作</value>
  </data>
  <data name="LoadConfigureError" xml:space="preserve">
    <value>加载配置属性文件{0}失败：

{1}</value>
  </data>
  <data name="LoadDebugDataError" xml:space="preserve">
    <value>加载调试数据文件{0}失败：

{1}</value>
  </data>
  <data name="SaveFileError" xml:space="preserve">
    <value>保存文件{0}失败：

{1}</value>
  </data>
  <data name="Const" xml:space="preserve">
    <value>常量</value>
  </data>
  <data name="Par" xml:space="preserve">
    <value>变量</value>
  </data>
  <data name="ParInfo" xml:space="preserve">
    <value>用户自定义变量</value>
  </data>
  <data name="PropertiesOf" xml:space="preserve">
    <value>{0}的属性</value>
  </data>
  <data name="Properties" xml:space="preserve">
    <value>属性</value>
  </data>
  <data name="AgentTypeError" xml:space="preserve">
    <value>Agent类型不兼容</value>
  </data>
  <data name="Disabled" xml:space="preserve">
    <value>被设置为禁用</value>
  </data>
  <data name="NoAgent" xml:space="preserve">
    <value>没有Agent</value>
  </data>
  <data name="NoMethod" xml:space="preserve">
    <value>没有方法</value>
  </data>
  <data name="ParWarningInfo" xml:space="preserve">
    <value>定义的par：'{0}'未被使用</value>
  </data>
  <data name="ReferenceError" xml:space="preserve">
    <value>引用的行为树包含错误</value>
  </data>
  <data name="Prototype" xml:space="preserve">
    <value>原型 : </value>
  </data>
  <data name="Description" xml:space="preserve">
    <value>描述 : </value>
  </data>
  <data name="TriggerMode" xml:space="preserve">
    <value>触发模式</value>
  </data>
  <data name="TriggerModeDesc" xml:space="preserve">
    <value>决定触发后对当前BT的影响以及被触发的子树结束时如何恢复</value>
  </data>
  <data name="EventNameDesc" xml:space="preserve">
    <value>触发的事件，C++端通过REGISTER_EVENT注册的事件名字</value>
  </data>
  <data name="EnterAction" xml:space="preserve">
    <value>进入动作</value>
  </data>
  <data name="EnterActionDesc" xml:space="preserve">
    <value>进入当前节点的时候执行的动作。这个可以为空不配置。</value>
  </data>
  <data name="ExitAction" xml:space="preserve">
    <value>退出动作</value>
  </data>
  <data name="ExitActionDesc" xml:space="preserve">
    <value>退出当前节点的时候执行的动作。这个可以为空不配置。可以调用behaviac::GetNodeExitStatus来知道节点是成功退出还是失败退出。</value>
  </data>
  <data name="NodeBasic" xml:space="preserve">
    <value>节点</value>
  </data>
  <data name="NoResultFunctor" xml:space="preserve">
    <value>没有设置决定状态的选项或函数：请选中该动作节点后，在其属性窗口中进行设置</value>
  </data>
  <data name="WrongResultFunctor" xml:space="preserve">
    <value>结果函数的返回值不是EBTStatus类型，或者其参数不是动作节点方法的返回值类型</value>
  </data>
  <data name="StatusFunctor" xml:space="preserve">
    <value>决定状态的函数</value>
  </data>
  <data name="StatusFunctorDesc" xml:space="preserve">
    <value>选择一个方法，将其返回值作为动作节点执行后的状态。
该方法只有一个或者没有参数，唯一参数的类型为动作节点方法的返回值类型，没有参数则表示动作节点的方法无返回值（void）</value>
  </data>
  <data name="StatusOption" xml:space="preserve">
    <value>决定状态的选项</value>
  </data>
  <data name="StatusOptionDesc" xml:space="preserve">
    <value>以下有3种设置来决定每次tick后动作节点的状态（成功、失败和正在运行）：
1. 如果动作节点的方法返回EBTStatus值，那么该值就直接作为动作节点的状态，“决定状态的选项”和“决定状态的函数”被禁用无需设置。
2. 否则，需要设置“决定状态的选项”：当选择Invalid值时，表明需要进一步设置“决定状态的函数”，否则直接使用“决定状态的选项”所选择的值。
3. 在“决定状态的函数”项中选择的函数，其返回值是EBTStatus，作为动作节点的状态。</value>
  </data>
  <data name="ReferenceWarning" xml:space="preserve">
    <value>引用的行为树包含警告</value>
  </data>
  <data name="LoadWorkspaceError" xml:space="preserve">
    <value>加载工作区文件{0}失败，请检查！</value>
  </data>
  <data name="Warning" xml:space="preserve">
    <value>警告</value>
  </data>
  <data name="UndoWarningInfo" xml:space="preserve">
    <value>对引用行为树"{0}" 最近一次的修改操作并未发生在当前行为树"{1}"中，因此当前的撤销/重做将会得到其他地方修改操作对应的结果。
确定继续该撤销/重做操作吗？</value>
  </data>
  <data name="Actions" xml:space="preserve">
    <value>动作</value>
  </data>
  <data name="TriggerMode_Return" xml:space="preserve">
    <value>返回</value>
  </data>
  <data name="TriggerMode_ReturnDesc" xml:space="preserve">
    <value>子树结束时返回控制到之前打断的节点，并继续执行</value>
  </data>
  <data name="TriggerMode_Transfer" xml:space="preserve">
    <value>转移</value>
  </data>
  <data name="TriggerMode_TransferDesc" xml:space="preserve">
    <value>原本的树将被终止并且重置，控制权交给新树。</value>
  </data>
  <data name="OperatorType" xml:space="preserve">
    <value>操作符类型</value>
  </data>
  <data name="OperatorTypeDesc" xml:space="preserve">
    <value>操作符类型选择</value>
  </data>
  <data name="OperatorType_And" xml:space="preserve">
    <value>与</value>
  </data>
  <data name="OperatorType_Equal" xml:space="preserve">
    <value>等于</value>
  </data>
  <data name="OperatorType_Greater" xml:space="preserve">
    <value>大于</value>
  </data>
  <data name="OperatorType_GreaterEqual" xml:space="preserve">
    <value>大于等于</value>
  </data>
  <data name="OperatorType_Less" xml:space="preserve">
    <value>小于</value>
  </data>
  <data name="OperatorType_LessEqual" xml:space="preserve">
    <value>小于等于</value>
  </data>
  <data name="OperatorType_NonEqual" xml:space="preserve">
    <value>不等于</value>
  </data>
  <data name="OperatorType_Or" xml:space="preserve">
    <value>或</value>
  </data>
  <data name="SaveWorkspaceError" xml:space="preserve">
    <value>保存工作区文件{0}失败，请检查！</value>
  </data>
  <data name="PreconditionFailResult" xml:space="preserve">
    <value>前提是false时动作的状态</value>
  </data>
  <data name="PreconditionFailResultDesc" xml:space="preserve">
    <value>当前提是false的时候，此动作的状态</value>
  </data>
  <data name="Prefab" xml:space="preserve">
    <value>预制</value>
  </data>
  <data name="PrefabDirty" xml:space="preserve">
    <value>预制修改与否</value>
  </data>
  <data name="PrefabName" xml:space="preserve">
    <value>预制名</value>
  </data>
  <data name="PrefabNodeId" xml:space="preserve">
    <value>预制节点Id</value>
  </data>
  <data name="AddEnterBreakpoint" xml:space="preserve">
    <value>添加进入断点</value>
  </data>
  <data name="DisableEnterBreakpoint" xml:space="preserve">
    <value>禁用进入断点</value>
  </data>
  <data name="RemoveEnterBreakpoint" xml:space="preserve">
    <value>删除进入断点</value>
  </data>
  <data name="AddExitBreakpoint" xml:space="preserve">
    <value>添加退出断点</value>
  </data>
  <data name="DisableExitBreakpoint" xml:space="preserve">
    <value>禁用退出断点</value>
  </data>
  <data name="RemoveExitBreakpoint" xml:space="preserve">
    <value>删除退出断点</value>
  </data>
  <data name="NoParam" xml:space="preserve">
    <value>参数没有设置完整</value>
  </data>
  <data name="AgentTypeChangedWarning" xml:space="preserve">
    <value>修改Agent类型后，已经设置的属性和方法可能被清空。确定该操作吗？</value>
  </data>
  <data name="Enter" xml:space="preserve">
    <value>进入</value>
  </data>
  <data name="Exit" xml:space="preserve">
    <value>退出</value>
  </data>
  <data name="Precondition" xml:space="preserve">
    <value>条件</value>
  </data>
  <data name="Effector" xml:space="preserve">
    <value>效果</value>
  </data>
  <data name="EffectorDesc" xml:space="preserve">
    <value>节点成功时执行</value>
  </data>
  <data name="EffectorPhase" xml:space="preserve">
    <value>执行时机</value>
  </data>
  <data name="EffectorPhaseDesc" xml:space="preserve">
    <value>什么时候起作用</value>
  </data>
  <data name="InterruptIf" xml:space="preserve">
    <value>中断条件</value>
  </data>
  <data name="Signal" xml:space="preserve">
    <value>信号</value>
  </data>
  <data name="TaskNoMethod" xml:space="preserve">
    <value>任务没有指定子节点</value>
  </data>
  <data name="OperatorType_Assignment" xml:space="preserve">
    <value>赋值</value>
  </data>
  <data name="OperatorType_In" xml:space="preserve">
    <value>遍历</value>
  </data>
  <data name="CustomizedMethodError" xml:space="preserve">
    <value>发现自定义的方法：请先将该方法所在Agent类的导出源码文件整合到自己的游戏项目中，并导出类型信息文件，然后回到编辑器中重新加载当前工作区后，再导出行为树。</value>
  </data>
  <data name="TaskMethodChildrenOrOne" xml:space="preserve">
    <value>任务节点只接受方法节点或者只是一个其他类型的节点</value>
  </data>
  <data name="Task" xml:space="preserve">
    <value>任务</value>
  </data>
  <data name="Behavior" xml:space="preserve">
    <value>行为树</value>
  </data>
  <data name="ReferencedBehavior" xml:space="preserve">
    <value>子树</value>
  </data>
  <data name="AddPlanningBreakpoint" xml:space="preserve">
    <value>添加规划断点</value>
  </data>
  <data name="DisablePlanningBreakpoint" xml:space="preserve">
    <value>禁用规划断点</value>
  </data>
  <data name="RemovePlanningBreakpoint" xml:space="preserve">
    <value>删除规划断点</value>
  </data>
  <data name="FileVersionWarning" xml:space="preserve">
    <value>请安装最新版的编辑器来打开这些行为树文件。</value>
  </data>
  <data name="Right" xml:space="preserve">
    <value>右参数</value>
  </data>
  <data name="Mode" xml:space="preserve">
    <value>模式</value>
  </data>
  <data name="ModeDesc" xml:space="preserve">
    <value>模式</value>
  </data>
  <data name="Attachment" xml:space="preserve">
    <value>附件</value>
  </data>
  <data name="AttachmentId" xml:space="preserve">
    <value>附件ID</value>
  </data>
  <data name="AttachmentIdDesc" xml:space="preserve">
    <value>附件ID</value>
  </data>
  <data name="Name" xml:space="preserve">
    <value>名字</value>
  </data>
  <data name="NameDesc" xml:space="preserve">
    <value>名字</value>
  </data>
  <data name="Method" xml:space="preserve">
    <value>方法</value>
  </data>
  <data name="FSM" xml:space="preserve">
    <value>状态机</value>
  </data>
  <data name="HTN" xml:space="preserve">
    <value>任务网络</value>
  </data>
  <data name="State" xml:space="preserve">
    <value>状态</value>
  </data>
  <data name="Transition" xml:space="preserve">
    <value>转换</value>
  </data>
  <data name="CustomizedAgentError" xml:space="preserve">
    <value>发现自定义的Agent类型：请先将导出的该Agent类的源码文件整合到自己的游戏项目中，并导出类型信息文件，然后回到编辑器中重新加载当前工作区后，再导出行为树。</value>
  </data>
  <data name="Error" xml:space="preserve">
    <value>错误</value>
  </data>
  <data name="MethodWithSameDisplayName" xml:space="preserve">
    <value>方法"{0}"和"{1}"具有相同的显示名 "{2}"，请修改它们的显示名，并重新导出为类型信息后再使用。</value>
  </data>
  <data name="PressF1" xml:space="preserve">
    <value>点击F1键查看文档</value>
  </data>
  <data name="ReferencedTreeOrMethodNeeded" xml:space="preserve">
    <value>请指定子树或者提供一个方法来返回子树</value>
  </data>
  <data name="ReferenceGenerator" xml:space="preserve">
    <value>可以指定一个方法，其返回值需要是一个字符串，用来指定子树。</value>
  </data>
  <data name="ReferenceGeneratorDesc" xml:space="preserve">
    <value>可以指定一个方法，其返回值需要是一个字符串，用来指定子树。</value>
  </data>
  <data name="InvalidMetaInfo" xml:space="preserve">
    <value>元数据文件有错误 : {0}
请用最新的运行时重新导出类型信息！</value>
  </data>
  <data name="AutoMergeMetaFilesInfo" xml:space="preserve">
    <value>多个类型信息文件将被自动合并，并删除掉旧的类型信息文件，确定吗？</value>
  </data>
  <data name="ReferencedBehaviorFilename" xml:space="preserve">
    <value>引用文件名</value>
  </data>
  <data name="Debug" xml:space="preserve">
    <value>调试</value>
  </data>
</root>